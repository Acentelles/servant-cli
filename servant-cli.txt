-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/mstksg/servant-cli#readme</a>
@package servant-cli
@version 0.1.0.0

module Servant.CLI.Structure

-- | How to "read" an option.
data OptRead :: Type -> Type
[ORRequired] :: ReadM a -> OptRead a
[OROptional] :: ReadM a -> OptRead (Maybe a)
[ORSwitch] :: OptRead Bool

-- | Query parameters are interpreted as options
data Opt a
Opt :: String -> String -> String -> Coyoneda OptRead a -> Opt a
[optName] :: Opt a -> String
[optDesc] :: Opt a -> String
[optMeta] :: Opt a -> String
[optRead] :: Opt a -> Coyoneda OptRead a

-- | Captures are interpreted as arguments
data Arg a
Arg :: String -> String -> String -> ReadM a -> Arg a
[argName] :: Arg a -> String
[argDesc] :: Arg a -> String
[argMeta] :: Arg a -> String
[argRead] :: Arg a -> ReadM a
data MultiArg :: Type -> Type
[MultiArg] :: Arg a -> MultiArg [a]
type Captures = Day Arg PStruct :+: Day MultiArg (Map Method :.: Endpoint)

-- | Endpoint arguments and body.
--   
--   TODO: add things like status etc.
data Endpoint a
Endpoint :: Day (Ap Opt) Parser a -> Endpoint a
[epStruct] :: Endpoint a -> Day (Ap Opt) Parser a

-- | Structure for a parser of a given value that may use items from
--   captures and arguments.
data PStruct a
PStruct :: [String] -> Map String (PStruct a) -> Maybe (Captures a) -> Map Method (Endpoint a) -> PStruct a
[psInfo] :: PStruct a -> [String]

-- | path components
[psComponents] :: PStruct a -> Map String (PStruct a)

-- | captures
[psCaptures] :: PStruct a -> Maybe (Captures a)

-- | endpoints
[psEndpoints] :: PStruct a -> Map Method (Endpoint a)
data PStructF (a_ah0J :: Type) r_ai1w
PStructF :: [[Char]] -> Map [Char] r_ai1w -> Maybe ((:+:) (Day Arg PStruct) (Day MultiArg ((:.:) (Map ByteString) Endpoint)) a_ah0J) -> Map ByteString (Endpoint a_ah0J) -> PStructF r_ai1w
[psInfoF] :: PStructF r_ai1w -> [[Char]]
[psComponentsF] :: PStructF r_ai1w -> Map [Char] r_ai1w
[psCapturesF] :: PStructF r_ai1w -> Maybe ((:+:) (Day Arg PStruct) (Day MultiArg ((:.:) (Map ByteString) Endpoint)) a_ah0J)
[psEndpointsF] :: PStructF r_ai1w -> Map ByteString (Endpoint a_ah0J)
structParser :: PStruct a -> ParserInfo a
structParser_ :: PStruct a -> Bool -> [String] -> ParserInfo a

-- | Combine two <a>PStruct</a>s, preferring the left hand side for
--   conflicts. If the left hand has a capture, the right hand's components
--   are ignored.
altPStruct :: PStruct a -> PStruct a -> PStruct a
branch :: PStruct a -> PStruct b -> PStruct (Either a b)
infixr 3 `branch`
($:>) :: String -> PStruct a -> PStruct a
infixr 4 $:>

-- | Add a request body. NOTE!!!!! UNDEFINED BEHAVIOR IF DONE MORE THAN
--   ONCE?
(%:>) :: Parser a -> PStruct (a -> b) -> PStruct b
infixr 4 %:>
(?:>) :: Opt a -> PStruct (a -> b) -> PStruct b
infixr 4 ?:>
(#:>) :: Arg a -> PStruct (a -> b) -> PStruct b
infixr 4 #:>
(##:>) :: Arg a -> PStruct ([a] -> b) -> PStruct b
infixr 4 ##:>
note :: String -> PStruct a -> PStruct a
infixr 4 `note`
endpoint :: Method -> a -> PStruct a
orRequired :: ReadM a -> Coyoneda OptRead a
orOptional :: ReadM a -> Coyoneda OptRead (Maybe a)
orSwitch :: Coyoneda OptRead Bool
instance Data.Traversable.Traversable (Servant.CLI.Structure.PStructF a)
instance Data.Foldable.Foldable (Servant.CLI.Structure.PStructF a)
instance GHC.Base.Functor (Servant.CLI.Structure.PStructF a)
instance Data.Functor.Foldable.Recursive (Servant.CLI.Structure.PStruct a)
instance Data.Functor.Foldable.Corecursive (Servant.CLI.Structure.PStruct a)
instance GHC.Base.Semigroup (Servant.CLI.Structure.PStruct a)
instance GHC.Base.Monoid (Servant.CLI.Structure.PStruct a)
instance GHC.Base.Functor Servant.CLI.Structure.PStruct
instance GHC.Base.Functor Servant.CLI.Structure.Endpoint
instance GHC.Base.Functor Servant.CLI.Structure.Arg
instance GHC.Base.Functor Servant.CLI.Structure.Opt

module Servant.CLI
class HasCLI m api where {
    type family CLI m api;
}
clientParser_ :: HasCLI m api => Proxy m -> Proxy api -> PStruct (Request -> CLI m api)
clientPStruct :: HasCLI m api => Proxy api -> Proxy m -> PStruct (CLI m api)
parseClient :: HasCLI ClientM api => Proxy api -> IO (CLI ClientM api)
class ParseBody a
parseBody :: ParseBody a => Parser a
parseBody :: (ParseBody a, Typeable a, Read a) => Parser a
defaultParseBody :: forall a. Typeable a => ReadM a -> Parser a

-- | The class that lets us display a sample input or output in the
--   supported content-types when generating documentation for endpoints
--   that either:
--   
--   <ul>
--   <li>expect a request body, or</li>
--   <li>return a non empty response body</li>
--   </ul>
--   
--   Example of an instance:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   import Data.Aeson
--   import Data.Text
--   import GHC.Generics
--   
--   data Greet = Greet { _msg :: Text }
--     deriving (Generic, Show)
--   
--   instance FromJSON Greet
--   instance ToJSON Greet
--   
--   instance ToSample Greet where
--     toSamples _ = singleSample g
--   
--       where g = Greet "Hello, haskeller!"
--   </pre>
--   
--   You can also instantiate this class using <a>toSamples</a> instead of
--   <a>toSample</a>: it lets you specify different responses along with
--   some context (as <a>ErrorMessage</a>) that explains when you're
--   supposed to get the corresponding response.
class ToSample a
toSamples :: ToSample a => Proxy a -> [(Text, a)]

-- | The class that helps us automatically get documentation for URL
--   captures.
--   
--   Example of an instance:
--   
--   <pre>
--   instance ToCapture (Capture "name" Text) where
--     toCapture _ = DocCapture "name" "name of the person to greet"
--   </pre>
class ToCapture (c :: k)
toCapture :: ToCapture c => Proxy c -> DocCapture

-- | A type to represent captures. Holds the name of the capture and a
--   description.
--   
--   Write a <a>ToCapture</a> instance for your captured types.
data DocCapture
DocCapture :: String -> String -> DocCapture
[_capSymbol] :: DocCapture -> String
[_capDesc] :: DocCapture -> String

-- | The class that helps us automatically get documentation for GET (or
--   other <a>Method</a>) parameters.
--   
--   Example of an instance:
--   
--   <pre>
--   instance ToParam (QueryParam' mods "capital" Bool) where
--     toParam _ =
--       DocQueryParam "capital"
--                     ["true", "false"]
--                     "Get the greeting message in uppercase (true) or not (false). Default is false."
--   </pre>
class ToParam (t :: k)
toParam :: ToParam t => Proxy t -> DocQueryParam

-- | A type to represent a <i>GET</i> (or other possible <a>Method</a>)
--   parameter from the Query String. Holds its name, the possible values
--   (leave empty if there isn't a finite number of them), and a
--   description of how it influences the output or behavior.
--   
--   Write a <a>ToParam</a> instance for your GET parameter types
data DocQueryParam
DocQueryParam :: String -> [String] -> String -> ParamKind -> DocQueryParam
[_paramName] :: DocQueryParam -> String
[_paramValues] :: DocQueryParam -> [String]
[_paramDesc] :: DocQueryParam -> String
[_paramKind] :: DocQueryParam -> ParamKind
instance forall k ct a (m :: k) api (mods :: [*]) (cts :: [*]). (Servant.API.ContentTypes.MimeRender ct a, Servant.CLI.ParseBody a, Servant.CLI.HasCLI m api) => Servant.CLI.HasCLI m (Servant.API.ReqBody.ReqBody' mods (ct : cts) a Servant.API.Sub.:> api)
instance Servant.CLI.ParseBody GHC.Base.String
instance Servant.CLI.ParseBody Data.Text.Internal.Text
instance Servant.CLI.ParseBody Data.Text.Internal.Lazy.Text
instance Servant.CLI.ParseBody GHC.Types.Int
instance Servant.CLI.ParseBody GHC.Integer.Type.Integer
instance Servant.CLI.ParseBody GHC.Types.Float
instance Servant.CLI.ParseBody GHC.Types.Double
instance forall k (m :: k). Servant.CLI.HasCLI m Servant.API.Empty.EmptyAPI
instance forall k (m :: k) a b. (Servant.CLI.HasCLI m a, Servant.CLI.HasCLI m b) => Servant.CLI.HasCLI m (a Servant.API.Alternative.:<|> b)
instance forall k (path :: GHC.Types.Symbol) (m :: k) api. (GHC.TypeLits.KnownSymbol path, Servant.CLI.HasCLI m api) => Servant.CLI.HasCLI m (path Servant.API.Sub.:> api)
instance forall k a (sym :: GHC.Types.Symbol) (m :: k) api (mods :: [*]). (Web.Internal.HttpApiData.FromHttpApiData a, Web.Internal.HttpApiData.ToHttpApiData a, Data.Typeable.Internal.Typeable a, Servant.Docs.Internal.ToCapture (Servant.API.Capture.Capture sym a), Servant.CLI.HasCLI m api) => Servant.CLI.HasCLI m (Servant.API.Capture.Capture' mods sym a Servant.API.Sub.:> api)
instance forall k (sym :: GHC.Types.Symbol) a (mods :: [*]) (m :: k) api. (GHC.TypeLits.KnownSymbol sym, Web.Internal.HttpApiData.FromHttpApiData a, Web.Internal.HttpApiData.ToHttpApiData a, Data.Singletons.Bool.SBoolI (Servant.API.Modifiers.FoldRequired' 'GHC.Types.False mods), Data.Typeable.Internal.Typeable a, Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParam' mods sym a), Servant.CLI.HasCLI m api) => Servant.CLI.HasCLI m (Servant.API.QueryParam.QueryParam' mods sym a Servant.API.Sub.:> api)
instance forall k (sym :: GHC.Types.Symbol) (m :: k) api. (GHC.TypeLits.KnownSymbol sym, Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryFlag sym), Servant.CLI.HasCLI m api) => Servant.CLI.HasCLI m (Servant.API.QueryParam.QueryFlag sym Servant.API.Sub.:> api)
instance forall k1 (m :: * -> *) (method :: k1) (status :: GHC.Types.Nat) (cts' :: [*]) a. (Servant.Client.Core.HasClient.HasClient m (Servant.API.Verbs.Verb method status cts' a), Servant.API.Verbs.ReflectMethod method) => Servant.CLI.HasCLI m (Servant.API.Verbs.Verb method status cts' a)
