-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Command line interface for Servant API clients
--   
--   Parse command line arguments into a servant client, from a servant
--   API, using <i>optparse-applicative</i> for parsing, displaying help,
--   and auto-completion.
--   
--   Hooks into the annotation system used by <i>servant-docs</i> to
--   provide descriptions for parameters and captures.
--   
--   See <tt>example/greet.hs</tt> for an example usage.
@package servant-cli
@version 0.1.0.0


-- | Internal module providing a data structure for representing structure
--   of command line parsers that can be manipulated as an ADT, as well as
--   functionality to interpret it as a <a>Parser</a> command line argument
--   parser.
module Servant.CLI.PStruct

-- | How to "read" an option.
data OptRead :: Type -> Type
[ORRequired] :: ReadM a -> OptRead a
[OROptional] :: ReadM a -> OptRead (Maybe a)
[ORSwitch] :: OptRead Bool

-- | Query parameters are interpreted as options
data Opt a
Opt :: String -> String -> String -> Maybe (NonEmpty String) -> Coyoneda OptRead a -> Opt a
[optName] :: Opt a -> String
[optDesc] :: Opt a -> String
[optMeta] :: Opt a -> String
[optVals] :: Opt a -> Maybe (NonEmpty String)
[optRead] :: Opt a -> Coyoneda OptRead a

-- | Captures are interpreted as arguments
data Arg a
Arg :: String -> String -> String -> ReadM a -> Arg a
[argName] :: Arg a -> String
[argDesc] :: Arg a -> String
[argMeta] :: Arg a -> String
[argRead] :: Arg a -> ReadM a

-- | Interpret an <a>Arg</a> as something that can be given repeatedly an
--   arbitrary number of times.
data MultiArg :: Type -> Type
[MultiArg] :: Arg a -> MultiArg [a]

-- | Captures can be a single capture leading to the next level, or a
--   multi-capture leading to an endpoint action.
type Captures = Day Arg PStruct :+: Day MultiArg EndpointMap

-- | Endpoint arguments and body.
data Endpoint a
Endpoint :: Day (Ap Opt) Parser a -> Endpoint a
[epStruct] :: Endpoint a -> Day (Ap Opt) Parser a

-- | A map of endpoints associated with methods, paired with an optional
--   "raw" endpoint.
data EndpointMap a
EPM :: Map Method (Endpoint a) -> Maybe (Day ((:~:) Method) Endpoint a) -> EndpointMap a
[epmGiven] :: EndpointMap a -> Map Method (Endpoint a)
[epmRaw] :: EndpointMap a -> Maybe (Day ((:~:) Method) Endpoint a)

-- | Structure for a parser of a given value that may use items from
--   captures and arguments.
data PStruct a
PStruct :: [String] -> Map String (PStruct a) -> Maybe (Captures a) -> EndpointMap a -> PStruct a
[psInfo] :: PStruct a -> [String]

-- | path components
[psComponents] :: PStruct a -> Map String (PStruct a)

-- | captures
[psCaptures] :: PStruct a -> Maybe (Captures a)
[psEndpoints] :: PStruct a -> EndpointMap a
data PStructF (a_agcn :: Type) r_ahf1
PStructF :: [[Char]] -> Map [Char] r_ahf1 -> Maybe ((:+:) (Day Arg PStruct) (Day MultiArg EndpointMap) a_agcn) -> EndpointMap a_agcn -> PStructF r_ahf1
[psInfoF] :: PStructF r_ahf1 -> [[Char]]
[psComponentsF] :: PStructF r_ahf1 -> Map [Char] r_ahf1
[psCapturesF] :: PStructF r_ahf1 -> Maybe ((:+:) (Day Arg PStruct) (Day MultiArg EndpointMap) a_agcn)
[psEndpointsF] :: PStructF r_ahf1 -> EndpointMap a_agcn

-- | Convert a <a>PStruct</a> into a command line argument parser, from the
--   <i>optparse-applicative</i> library. It can be run with
--   <a>execParser</a>.
--   
--   It takes options on how the top-level prompt is displayed when given
--   <tt>"--help"</tt>; it can be useful for adding a header or program
--   description. Otherwise, just use <a>mempty</a>.
structParser :: PStruct a -> InfoMod a -> ParserInfo a

-- | Low-level implementation of <a>structParser</a>.
structParser_ :: PStruct a -> Bool -> [String] -> InfoMod a -> ParserInfo a

-- | Combine two <a>PStruct</a>s in an either-or fashion, favoring the left
--   hand side.
branch :: PStruct a -> PStruct b -> PStruct (Either a b)
infixr 3 `branch`

-- | Shift by a path component.
($:>) :: String -> PStruct a -> PStruct a
infixr 4 $:>

-- | Add a request body to all endpoints. NOTE!!!!! UNDEFINED BEHAVIOR IF
--   DONE MORE THAN ONCE?
(%:>) :: Parser a -> PStruct (a -> b) -> PStruct b
infixr 4 %:>

-- | Add a command-line option to all endpoints.
(?:>) :: Opt a -> PStruct (a -> b) -> PStruct b
infixr 4 ?:>

-- | Add a single argument praser.
(#:>) :: Arg a -> PStruct (a -> b) -> PStruct b
infixr 4 #:>

-- | Add a repeating argument parser.
(##:>) :: Arg a -> PStruct ([a] -> b) -> PStruct b
infixr 4 ##:>

-- | Add a note.
note :: String -> PStruct a -> PStruct a
infixr 4 `note`

-- | Create an endpoint action.
endpoint :: Method -> a -> PStruct a

-- | Create a raw endpoint.
rawEndpoint :: (Method -> a) -> PStruct a

-- | Helper to lift a <a>ReadM</a> into something that can be used with
--   <a>optRead</a>.
orRequired :: ReadM a -> Coyoneda OptRead a

-- | Helper to lift an optional <a>ReadM</a> into something that can be
--   used with <a>optRead</a>.
orOptional :: ReadM a -> Coyoneda OptRead (Maybe a)

-- | An <a>optRead</a> that is on-or-off.
orSwitch :: Coyoneda OptRead Bool
instance Data.Traversable.Traversable (Servant.CLI.PStruct.PStructF a)
instance Data.Foldable.Foldable (Servant.CLI.PStruct.PStructF a)
instance GHC.Base.Functor (Servant.CLI.PStruct.PStructF a)
instance Data.Functor.Foldable.Recursive (Servant.CLI.PStruct.PStruct a)
instance Data.Functor.Foldable.Corecursive (Servant.CLI.PStruct.PStruct a)
instance GHC.Base.Semigroup (Servant.CLI.PStruct.EndpointMap a)
instance GHC.Base.Monoid (Servant.CLI.PStruct.EndpointMap a)
instance GHC.Base.Semigroup (Servant.CLI.PStruct.PStruct a)
instance GHC.Base.Monoid (Servant.CLI.PStruct.PStruct a)
instance GHC.Base.Functor Servant.CLI.PStruct.PStruct
instance GHC.Base.Functor Servant.CLI.PStruct.EndpointMap
instance GHC.Base.Functor Servant.CLI.PStruct.Endpoint
instance GHC.Base.Functor Servant.CLI.PStruct.Arg
instance GHC.Base.Functor Servant.CLI.PStruct.Opt


-- | Provides the interface for <a>ParseBody</a>, a helper class for
--   defining directly how to parse request bodies.
module Servant.CLI.ParseBody

-- | A helper class for defining directly how to parse request bodies. This
--   allows more complex parsing of bodies.
--   
--   You need an instance of this for every type you use with
--   <tt>ReqBody</tt>.
class ParseBody a
parseBody :: ParseBody a => Parser a
parseBody :: (ParseBody a, Typeable a, Read a) => Parser a

-- | Default implementation that expects a <tt>--data</tt> option.
defaultParseBody :: String -> ReadM a -> Parser a
instance Servant.CLI.ParseBody.ParseBody Data.Text.Internal.Text
instance Servant.CLI.ParseBody.ParseBody Data.Text.Internal.Lazy.Text
instance Servant.CLI.ParseBody.ParseBody GHC.Types.Int
instance Servant.CLI.ParseBody.ParseBody GHC.Integer.Type.Integer
instance Servant.CLI.ParseBody.ParseBody GHC.Types.Float
instance Servant.CLI.ParseBody.ParseBody GHC.Types.Double


-- | Main module providing underlying functionality for the command line
--   interface parser for servant API clients.
--   
--   For the most part, you can ignore this module unless you're adding new
--   API combinators.
module Servant.CLI.HasCLI

-- | Typeclass defining how each API combinator influences how a server can
--   be interacted with using command line options.
--   
--   Note that query parameters and captures all require
--   <i>servant-docs</i> annotation instances, to allow for proper help
--   messages.
--   
--   Unless you are adding new combinators to be used with APIs, you can
--   ignore this class.
class HasCLI m api where {
    
    -- | List of extra parameters that must be generated at runtime to produce
    --   the desired request.
    --   
    --   For most routes this will be an empty list, but it is non-empty for
    --   <a>StreamBody</a>, <a>BasicAuth</a>, and <a>AuthProtect</a>.
    type family CLIParam (m :: Type -> Type) (api :: Type) :: [Type];
    
    -- | The parsed type of the client request response. Usually this will be a
    --   bunch of nested <a>Either</a>s for every API endpoint, nested
    --   according to the <a>:&lt;|&gt;</a>s in the API.
    type family CLIResult (m :: Type -> Type) (api :: Type) :: Type;
    
    -- | The type of a data structure to conveniently handle the results of all
    --   pontential endpoints. This is useful because it is often tedious to
    --   handle the bunch of nested <a>Either</a>s that <a>CLIResult</a> has.
    --   
    --   It essentially lets you specify how to combine each potential
    --   endpoint's response into a single output value.
    --   
    --   Usually this will be a bunch of nested <a>:&lt;|&gt;</a>s which handle
    --   each endpoint, according to the <a>:&lt;|&gt;</a>s in the API. It
    --   mirrors the structure of <a>Client</a> and <a>ServerT</a>.
    --   
    --   Used with functions like <tt>parseHandleClient</tt>.
    type family CLIHandler (m :: Type -> Type) (api :: Type) (r :: Type) :: Type;
}

-- | Generate a <a>PStruct</a> showing how to modify a <a>Request</a> and
--   perform an action, given an API and underlying monad. Only meant for
--   internal use; should be used through <a>cliPStruct</a> instead.
--   
--   Takes a <a>Rec</a> of actions to generate required items. Pass in
--   <a>RNil</a> if no parameters are expected (that is, if
--   <tt><a>CLIParam</a> m api</tt> is an empty list). The actions will
--   only be run if they are needed.
cliPStruct_ :: HasCLI m api => Proxy m -> Proxy api -> Rec m (CLIParam m api) -> PStruct (Request -> m (CLIResult m api))

-- | Handle all the possibilities in a <a>CLIResult</a>, by giving the
--   appropriate <a>CLIHandler</a>.
cliHandler :: HasCLI m api => Proxy m -> Proxy api -> CLIHandler m api r -> CLIResult m api -> r

-- | Un-append two <a>Rec</a>s.
splitRec :: forall as bs g. RecApplicative as => Rec g (as ++ bs) -> (Rec g as, Rec g bs)
instance Servant.CLI.HasCLI.HasCLI m Servant.API.Empty.EmptyAPI
instance (Servant.CLI.HasCLI.HasCLI m a, Servant.CLI.HasCLI.HasCLI m b, GHC.Base.Functor m, Data.Vinyl.Core.RecApplicative (Servant.CLI.HasCLI.CLIParam m a)) => Servant.CLI.HasCLI.HasCLI m (a Servant.API.Alternative.:<|> b)
instance (GHC.TypeLits.KnownSymbol path, Servant.CLI.HasCLI.HasCLI m api) => Servant.CLI.HasCLI.HasCLI m (path Servant.API.Sub.:> api)
instance (Web.Internal.HttpApiData.FromHttpApiData a, Web.Internal.HttpApiData.ToHttpApiData a, Data.Typeable.Internal.Typeable a, Servant.Docs.Internal.ToCapture (Servant.API.Capture.Capture sym a), Servant.CLI.HasCLI.HasCLI m api) => Servant.CLI.HasCLI.HasCLI m (Servant.API.Capture.Capture' mods sym a Servant.API.Sub.:> api)
instance (Web.Internal.HttpApiData.FromHttpApiData a, Web.Internal.HttpApiData.ToHttpApiData a, Data.Typeable.Internal.Typeable a, Servant.Docs.Internal.ToCapture (Servant.API.Capture.CaptureAll sym a), Servant.CLI.HasCLI.HasCLI m api) => Servant.CLI.HasCLI.HasCLI m (Servant.API.Capture.CaptureAll sym a Servant.API.Sub.:> api)
instance (GHC.TypeLits.KnownSymbol sym, Web.Internal.HttpApiData.FromHttpApiData a, Web.Internal.HttpApiData.ToHttpApiData a, Data.Singletons.Bool.SBoolI (Servant.API.Modifiers.FoldRequired' 'GHC.Types.False mods), Data.Typeable.Internal.Typeable a, Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParam' mods sym a), Servant.CLI.HasCLI.HasCLI m api) => Servant.CLI.HasCLI.HasCLI m (Servant.API.QueryParam.QueryParam' mods sym a Servant.API.Sub.:> api)
instance (GHC.TypeLits.KnownSymbol sym, Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryFlag sym), Servant.CLI.HasCLI.HasCLI m api) => Servant.CLI.HasCLI.HasCLI m (Servant.API.QueryParam.QueryFlag sym Servant.API.Sub.:> api)
instance (Servant.API.ContentTypes.MimeRender ct a, Servant.CLI.ParseBody.ParseBody a, Servant.CLI.HasCLI.HasCLI m api) => Servant.CLI.HasCLI.HasCLI m (Servant.API.ReqBody.ReqBody' mods (ct : cts) a Servant.API.Sub.:> api)
instance forall k1 (m :: * -> *) (method :: k1) (status :: GHC.Types.Nat) (cts' :: [*]) a. (Servant.Client.Core.HasClient.HasClient m (Servant.API.Verbs.Verb method status cts' a), Servant.API.Verbs.ReflectMethod method) => Servant.CLI.HasCLI.HasCLI m (Servant.API.Verbs.Verb method status cts' a)
instance forall k1 (m :: * -> *) ct chunk (method :: k1) framing a (status :: GHC.Types.Nat). (Servant.Client.Core.RunClient.RunStreamingClient m, Servant.API.ContentTypes.MimeUnrender ct chunk, Servant.API.Verbs.ReflectMethod method, Servant.API.Stream.FramingUnrender framing, Servant.API.Stream.FromSourceIO chunk a) => Servant.CLI.HasCLI.HasCLI m (Servant.API.Stream.Stream method status framing ct a)
instance (Servant.API.Stream.ToSourceIO chunk a, Servant.API.ContentTypes.MimeRender ctype chunk, Servant.API.Stream.FramingRender framing, Servant.CLI.HasCLI.HasCLI m api, GHC.Base.Monad m) => Servant.CLI.HasCLI.HasCLI m (Servant.API.Stream.StreamBody' mods framing ctype a Servant.API.Sub.:> api)
instance (GHC.TypeLits.KnownSymbol sym, Web.Internal.HttpApiData.FromHttpApiData a, Web.Internal.HttpApiData.ToHttpApiData a, Data.Singletons.Bool.SBoolI (Servant.API.Modifiers.FoldRequired' 'GHC.Types.False mods), Data.Typeable.Internal.Typeable a, Servant.CLI.HasCLI.HasCLI m api) => Servant.CLI.HasCLI.HasCLI m (Servant.API.Header.Header' mods sym a Servant.API.Sub.:> api)
instance Servant.CLI.HasCLI.HasCLI m api => Servant.CLI.HasCLI.HasCLI m (Network.HTTP.Types.Version.HttpVersion Servant.API.Sub.:> api)
instance (GHC.TypeLits.KnownSymbol desc, Servant.CLI.HasCLI.HasCLI m api) => Servant.CLI.HasCLI.HasCLI m (Servant.API.Description.Summary desc Servant.API.Sub.:> api)
instance (GHC.TypeLits.KnownSymbol desc, Servant.CLI.HasCLI.HasCLI m api) => Servant.CLI.HasCLI.HasCLI m (Servant.API.Description.Description desc Servant.API.Sub.:> api)
instance Servant.Client.Core.RunClient.RunClient m => Servant.CLI.HasCLI.HasCLI m Servant.API.Raw.Raw
instance Servant.CLI.HasCLI.HasCLI m api => Servant.CLI.HasCLI.HasCLI m (Data.Vault.Lazy.Vault Servant.API.Sub.:> api)
instance Servant.CLI.HasCLI.HasCLI m api => Servant.CLI.HasCLI.HasCLI m (Servant.API.RemoteHost.RemoteHost Servant.API.Sub.:> api)
instance Servant.CLI.HasCLI.HasCLI m api => Servant.CLI.HasCLI.HasCLI m (Servant.API.IsSecure.IsSecure Servant.API.Sub.:> api)
instance Servant.CLI.HasCLI.HasCLI m subapi => Servant.CLI.HasCLI.HasCLI m (Servant.API.WithNamedContext.WithNamedContext name context subapi)
instance forall k (m :: * -> *) api (tag :: k). (Servant.CLI.HasCLI.HasCLI m api, GHC.Base.Monad m) => Servant.CLI.HasCLI.HasCLI m (Servant.API.Experimental.Auth.AuthProtect tag Servant.API.Sub.:> api)
instance (Servant.CLI.HasCLI.HasCLI m api, GHC.Base.Monad m) => Servant.CLI.HasCLI.HasCLI m (Servant.API.BasicAuth.BasicAuth realm usr Servant.API.Sub.:> api)


-- | Parse command line arguments into a servant client, from a servant
--   API.
--   
--   Mainly used through <a>parseClient</a> and <a>parseHandleClient</a>.
--   <a>parseClient</a> returns a servant client action that returns nested
--   <a>Either</a>s for every endpoint, but <a>parseHandleClient</a> allows
--   you to conveniently specify how you want to combine each endpoint
--   entry into a single result.
module Servant.CLI

-- | Parse a servant client; the result can be run. A good choice of
--   <tt>m</tt> is <a>ClientM</a>.
--   
--   Returns the request response, which is usually a layer of
--   <a>Either</a> for every endpoint branch. You can find the response
--   type directly by using typed holes or asking ghci with <tt>:t</tt> or
--   <tt>:kind! forall m. CLIResult m MyAPI</tt>. Because it might be
--   tedious handling nested <a>Either</a>s, see <a>parseHandleClient</a>
--   for a way to handle each potential branch in a convenient way.
--   
--   Takes a <a>Rec</a> of actions to generate required items. Pass in
--   <a>RNil</a> if no parameters are expected (that is, if
--   <tt><a>CLIParam</a> m api</tt> is an empty list), or use
--   <a>parseClient'</a>. The actions will only be run if they are needed.
--   
--   Takes options on how the top-level prompt is displayed when given
--   <tt>"--help"</tt>; it can be useful for adding a header or program
--   description. Otherwise, just use <a>mempty</a>.
parseClient :: HasCLI m api => Proxy api -> Proxy m -> Rec m (CLIParam m api) -> InfoMod (m (CLIResult m api)) -> IO (m (CLIResult m api))

-- | Parse a server client, like <a>parseClient</a>. However, instead of
--   that client action returning the request response, instead use a
--   <a>CLIHandler</a> to handle every potential request response. It
--   essentially lets you specify how to combine each potential endpoint's
--   response into a single output value.
--   
--   The handler is usually a <a>:&lt;|&gt;</a> for every endpoint branch.
--   You can find it by using typed holes or asking ghci with <tt>:t</tt>
--   or <tt>:kind! forall m r. CLIHandler m MyAPI r</tt>.
--   
--   Takes a <a>Rec</a> of actions to generate required items. Pass in
--   <a>RNil</a> if no parameters are expected (that is, if
--   <tt><a>CLIParam</a> m api</tt> is an empty list), or use
--   <a>parseHandleClient'</a>. The actions will only be run if they are
--   needed.
--   
--   Takes options on how the top-level prompt is displayed when given
--   <tt>"--help"</tt>; it can be useful for adding a header or program
--   description. Otherwise, just use <a>mempty</a>.
parseHandleClient :: (HasCLI m api, Functor m) => Proxy api -> Proxy m -> Rec m (CLIParam m api) -> InfoMod (m (CLIResult m api)) -> CLIHandler m api r -> IO (m r)

-- | A version of <a>parseClient</a> that works when the client action
--   requires no extra parameters.
parseClient' :: (HasCLI m api, CLIParam m api ~ '[]) => Proxy api -> Proxy m -> InfoMod (m (CLIResult m api)) -> IO (m (CLIResult m api))

-- | A version of <a>parseHandleClient</a> that works when the client
--   action requires
parseHandleClient' :: (HasCLI m api, Functor m, CLIParam m api ~ '[]) => Proxy api -> Proxy m -> InfoMod (m (CLIResult m api)) -> CLIHandler m api r -> IO (m r)

-- | Typeclass defining how each API combinator influences how a server can
--   be interacted with using command line options.
--   
--   Note that query parameters and captures all require
--   <i>servant-docs</i> annotation instances, to allow for proper help
--   messages.
--   
--   Unless you are adding new combinators to be used with APIs, you can
--   ignore this class.
class HasCLI m api where {
    
    -- | List of extra parameters that must be generated at runtime to produce
    --   the desired request.
    --   
    --   For most routes this will be an empty list, but it is non-empty for
    --   <a>StreamBody</a>, <a>BasicAuth</a>, and <a>AuthProtect</a>.
    type family CLIParam (m :: Type -> Type) (api :: Type) :: [Type];
    
    -- | The parsed type of the client request response. Usually this will be a
    --   bunch of nested <a>Either</a>s for every API endpoint, nested
    --   according to the <a>:&lt;|&gt;</a>s in the API.
    type family CLIResult (m :: Type -> Type) (api :: Type) :: Type;
    
    -- | The type of a data structure to conveniently handle the results of all
    --   pontential endpoints. This is useful because it is often tedious to
    --   handle the bunch of nested <a>Either</a>s that <a>CLIResult</a> has.
    --   
    --   It essentially lets you specify how to combine each potential
    --   endpoint's response into a single output value.
    --   
    --   Usually this will be a bunch of nested <a>:&lt;|&gt;</a>s which handle
    --   each endpoint, according to the <a>:&lt;|&gt;</a>s in the API. It
    --   mirrors the structure of <a>Client</a> and <a>ServerT</a>.
    --   
    --   Used with functions like <tt>parseHandleClient</tt>.
    type family CLIHandler (m :: Type -> Type) (api :: Type) (r :: Type) :: Type;
}

-- | Handle all the possibilities in a <a>CLIResult</a>, by giving the
--   appropriate <a>CLIHandler</a>.
cliHandler :: HasCLI m api => Proxy m -> Proxy api -> CLIHandler m api r -> CLIResult m api -> r

-- | Create a structure for a command line parser.
--   
--   Takes a <a>Rec</a> of actions to generate required items. Pass in
--   <a>RNil</a> if no parameters are expected (that is, if
--   <tt><a>CLIParam</a> m api</tt> is an empty list). The actions will
--   only be run if they are needed.
cliPStruct :: HasCLI m api => Proxy m -> Proxy api -> Rec m (CLIParam m api) -> PStruct (m (CLIResult m api))

-- | A version of <a>cliPStruct</a> that works when the client action
--   requires no extra parameters.
cliPStruct' :: (HasCLI m api, CLIParam m api ~ '[]) => Proxy m -> Proxy api -> PStruct (m (CLIResult m api))

-- | Convert a <a>PStruct</a> into a command line argument parser, from the
--   <i>optparse-applicative</i> library. It can be run with
--   <a>execParser</a>.
--   
--   It takes options on how the top-level prompt is displayed when given
--   <tt>"--help"</tt>; it can be useful for adding a header or program
--   description. Otherwise, just use <a>mempty</a>.
structParser :: PStruct a -> InfoMod a -> ParserInfo a

-- | A helper class for defining directly how to parse request bodies. This
--   allows more complex parsing of bodies.
--   
--   You need an instance of this for every type you use with
--   <tt>ReqBody</tt>.
class ParseBody a
parseBody :: ParseBody a => Parser a
parseBody :: (ParseBody a, Typeable a, Read a) => Parser a

-- | Default implementation that expects a <tt>--data</tt> option.
defaultParseBody :: String -> ReadM a -> Parser a

-- | The class that helps us automatically get documentation for URL
--   captures.
--   
--   Example of an instance:
--   
--   <pre>
--   instance ToCapture (Capture "name" Text) where
--     toCapture _ = DocCapture "name" "name of the person to greet"
--   </pre>
class ToCapture (c :: k)
toCapture :: ToCapture c => Proxy c -> DocCapture

-- | A type to represent captures. Holds the name of the capture and a
--   description.
--   
--   Write a <a>ToCapture</a> instance for your captured types.
data DocCapture
DocCapture :: String -> String -> DocCapture
[_capSymbol] :: DocCapture -> String
[_capDesc] :: DocCapture -> String

-- | The class that helps us automatically get documentation for GET (or
--   other <a>Method</a>) parameters.
--   
--   Example of an instance:
--   
--   <pre>
--   instance ToParam (QueryParam' mods "capital" Bool) where
--     toParam _ =
--       DocQueryParam "capital"
--                     ["true", "false"]
--                     "Get the greeting message in uppercase (true) or not (false). Default is false."
--   </pre>
class ToParam (t :: k)
toParam :: ToParam t => Proxy t -> DocQueryParam

-- | A type to represent a <i>GET</i> (or other possible <a>Method</a>)
--   parameter from the Query String. Holds its name, the possible values
--   (leave empty if there isn't a finite number of them), and a
--   description of how it influences the output or behavior.
--   
--   Write a <a>ToParam</a> instance for your GET parameter types
data DocQueryParam
DocQueryParam :: String -> [String] -> String -> ParamKind -> DocQueryParam
[_paramName] :: DocQueryParam -> String
[_paramValues] :: DocQueryParam -> [String]
[_paramDesc] :: DocQueryParam -> String
[_paramKind] :: DocQueryParam -> ParamKind

-- | Type of GET (or other <a>Method</a>) parameter:
--   
--   <ul>
--   <li>Normal corresponds to <tt>QueryParam</tt>, i.e your usual GET
--   parameter</li>
--   <li>List corresponds to <tt>QueryParams</tt>, i.e GET parameters with
--   multiple values</li>
--   <li>Flag corresponds to <tt>QueryFlag</tt>, i.e a value-less GET
--   parameter</li>
--   </ul>
data ParamKind
Normal :: ParamKind
List :: ParamKind
Flag :: ParamKind
