-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/mstksg/servant-cli#readme</a>
@package servant-cli
@version 0.1.0.0

module Servant.CLI.Structure

-- | How to "read" an option.
data OptRead :: Type -> Type
[ORRequired] :: ReadM a -> OptRead a
[OROptional] :: ReadM a -> OptRead (Maybe a)
[ORSwitch] :: OptRead Bool

-- | Query parameters are interpreted as options
data Opt a
Opt :: String -> String -> String -> Maybe (NonEmpty String) -> Coyoneda OptRead a -> Opt a
[optName] :: Opt a -> String
[optDesc] :: Opt a -> String
[optMeta] :: Opt a -> String
[optVals] :: Opt a -> Maybe (NonEmpty String)
[optRead] :: Opt a -> Coyoneda OptRead a

-- | Captures are interpreted as arguments
data Arg a
Arg :: String -> String -> String -> ReadM a -> Arg a
[argName] :: Arg a -> String
[argDesc] :: Arg a -> String
[argMeta] :: Arg a -> String
[argRead] :: Arg a -> ReadM a
data MultiArg :: Type -> Type
[MultiArg] :: Arg a -> MultiArg [a]
type Captures = Day Arg PStruct :+: Day MultiArg EndpointMap

-- | Endpoint arguments and body.
--   
--   TODO: add things like status etc.
data Endpoint a
Endpoint :: Day (Ap Opt) Parser a -> Endpoint a
[epStruct] :: Endpoint a -> Day (Ap Opt) Parser a
data EndpointMap a
EPM :: Map Method (Endpoint a) -> Maybe (Day ((:~:) Method) Endpoint a) -> EndpointMap a
[epmGiven] :: EndpointMap a -> Map Method (Endpoint a)
[epmRaw] :: EndpointMap a -> Maybe (Day ((:~:) Method) Endpoint a)

-- | Structure for a parser of a given value that may use items from
--   captures and arguments.
data PStruct a
PStruct :: [String] -> Map String (PStruct a) -> Maybe (Captures a) -> EndpointMap a -> PStruct a
[psInfo] :: PStruct a -> [String]

-- | path components
[psComponents] :: PStruct a -> Map String (PStruct a)

-- | captures
[psCaptures] :: PStruct a -> Maybe (Captures a)
[psEndpoints] :: PStruct a -> EndpointMap a
data PStructF (a_ah0f :: Type) r_ai2T
PStructF :: [[Char]] -> Map [Char] r_ai2T -> Maybe ((:+:) (Day Arg PStruct) (Day MultiArg EndpointMap) a_ah0f) -> EndpointMap a_ah0f -> PStructF r_ai2T
[psInfoF] :: PStructF r_ai2T -> [[Char]]
[psComponentsF] :: PStructF r_ai2T -> Map [Char] r_ai2T
[psCapturesF] :: PStructF r_ai2T -> Maybe ((:+:) (Day Arg PStruct) (Day MultiArg EndpointMap) a_ah0f)
[psEndpointsF] :: PStructF r_ai2T -> EndpointMap a_ah0f

-- | Convert a <a>PStruct</a> into a command line argument parser, from the
--   <i>optparse-applicative</i> library. It can be run with
--   <a>execParser</a>.
--   
--   It takes options on how the top-level prompt is displayed when given
--   <tt>"--help"</tt>; it can be useful for adding a header or program
--   description. Otherwise, just use <a>mempty</a>.
structParser :: PStruct a -> InfoMod a -> ParserInfo a

-- | Low-level implementation of <a>structParser</a>.
structParser_ :: PStruct a -> Bool -> [String] -> InfoMod a -> ParserInfo a

-- | Combine two <a>PStruct</a>s, preferring the left hand side for
--   conflicts. If the left hand has a capture, the right hand's components
--   are ignored. If the left hand has a raw endpoint, the right hand's
--   endpoints are ignored.
altPStruct :: PStruct a -> PStruct a -> PStruct a

-- | Combine two <a>EndpointMap</a>s, preferring the left hand side for
--   conflicts. If the left hand has a raw endpoint, the right hand's
--   endpoints are ignored.
altEPM :: EndpointMap a -> EndpointMap a -> EndpointMap a
branch :: PStruct a -> PStruct b -> PStruct (Either a b)
infixr 3 `branch`

-- | Shift by a path component.
($:>) :: String -> PStruct a -> PStruct a
infixr 4 $:>

-- | Add a request body to all endpoints. NOTE!!!!! UNDEFINED BEHAVIOR IF
--   DONE MORE THAN ONCE?
(%:>) :: Parser a -> PStruct (a -> b) -> PStruct b
infixr 4 %:>

-- | Add a command-line option to all endpoints.
(?:>) :: Opt a -> PStruct (a -> b) -> PStruct b
infixr 4 ?:>

-- | Add a single argument praser.
(#:>) :: Arg a -> PStruct (a -> b) -> PStruct b
infixr 4 #:>

-- | Add a repeating argument parser.
(##:>) :: Arg a -> PStruct ([a] -> b) -> PStruct b
infixr 4 ##:>

-- | Add a note.
note :: String -> PStruct a -> PStruct a
infixr 4 `note`

-- | Create an endpoint action.
endpoint :: Method -> a -> PStruct a

-- | Create a raw endpoint.
rawEndpoint :: (Method -> a) -> PStruct a

-- | Helper to lift a <a>ReadM</a> into something that can be used with
--   <a>optRead</a>.
orRequired :: ReadM a -> Coyoneda OptRead a

-- | Helper to lift an optional <a>ReadM</a> into something that can be
--   used with <a>optRead</a>.
orOptional :: ReadM a -> Coyoneda OptRead (Maybe a)

-- | An <a>optRead</a> that is on-or-off.
orSwitch :: Coyoneda OptRead Bool
instance Data.Traversable.Traversable (Servant.CLI.Structure.PStructF a)
instance Data.Foldable.Foldable (Servant.CLI.Structure.PStructF a)
instance GHC.Base.Functor (Servant.CLI.Structure.PStructF a)
instance Data.Functor.Foldable.Recursive (Servant.CLI.Structure.PStruct a)
instance Data.Functor.Foldable.Corecursive (Servant.CLI.Structure.PStruct a)
instance GHC.Base.Semigroup (Servant.CLI.Structure.EndpointMap a)
instance GHC.Base.Monoid (Servant.CLI.Structure.EndpointMap a)
instance GHC.Base.Semigroup (Servant.CLI.Structure.PStruct a)
instance GHC.Base.Monoid (Servant.CLI.Structure.PStruct a)
instance GHC.Base.Functor Servant.CLI.Structure.PStruct
instance GHC.Base.Functor Servant.CLI.Structure.EndpointMap
instance GHC.Base.Functor Servant.CLI.Structure.Endpoint
instance GHC.Base.Functor Servant.CLI.Structure.Arg
instance GHC.Base.Functor Servant.CLI.Structure.Opt

module Servant.CLI.Internal

-- | Typeclass defining how each API combinator influences how a server can
--   be interacted with using command line options.
--   
--   Unless you are adding new combinators to be used with APIs, you can
--   ignore this class.
class HasCLI m api where {
    type family CLI (m :: Type -> Type) (api :: Type) :: Type;
}
clientPStruct_ :: HasCLI m api => Proxy m -> Proxy api -> PStruct (Request -> CLI m api)

-- | A helper class for defining directly how to parse request bodies. This
--   allows more complex parsing of bodies.
class ParseBody a
parseBody :: ParseBody a => Parser a
parseBody :: (ParseBody a, Typeable a, Read a) => Parser a
defaultParseBody :: String -> ReadM a -> Parser a
instance (Servant.API.ContentTypes.MimeRender ct a, Servant.CLI.Internal.ParseBody a, Servant.CLI.Internal.HasCLI m api) => Servant.CLI.Internal.HasCLI m (Servant.API.ReqBody.ReqBody' mods (ct : cts) a Servant.API.Sub.:> api)
instance Servant.CLI.Internal.ParseBody GHC.Base.String
instance Servant.CLI.Internal.ParseBody Data.Text.Internal.Text
instance Servant.CLI.Internal.ParseBody Data.Text.Internal.Lazy.Text
instance Servant.CLI.Internal.ParseBody GHC.Types.Int
instance Servant.CLI.Internal.ParseBody GHC.Integer.Type.Integer
instance Servant.CLI.Internal.ParseBody GHC.Types.Float
instance Servant.CLI.Internal.ParseBody GHC.Types.Double
instance Servant.CLI.Internal.HasCLI m Servant.API.Empty.EmptyAPI
instance (Servant.CLI.Internal.HasCLI m a, Servant.CLI.Internal.HasCLI m b) => Servant.CLI.Internal.HasCLI m (a Servant.API.Alternative.:<|> b)
instance (GHC.TypeLits.KnownSymbol path, Servant.CLI.Internal.HasCLI m api) => Servant.CLI.Internal.HasCLI m (path Servant.API.Sub.:> api)
instance (Web.Internal.HttpApiData.FromHttpApiData a, Web.Internal.HttpApiData.ToHttpApiData a, Data.Typeable.Internal.Typeable a, Servant.Docs.Internal.ToCapture (Servant.API.Capture.Capture sym a), Servant.CLI.Internal.HasCLI m api) => Servant.CLI.Internal.HasCLI m (Servant.API.Capture.Capture' mods sym a Servant.API.Sub.:> api)
instance (Web.Internal.HttpApiData.FromHttpApiData a, Web.Internal.HttpApiData.ToHttpApiData a, Data.Typeable.Internal.Typeable a, Servant.Docs.Internal.ToCapture (Servant.API.Capture.CaptureAll sym a), Servant.CLI.Internal.HasCLI m api) => Servant.CLI.Internal.HasCLI m (Servant.API.Capture.CaptureAll sym a Servant.API.Sub.:> api)
instance (GHC.TypeLits.KnownSymbol sym, Web.Internal.HttpApiData.FromHttpApiData a, Web.Internal.HttpApiData.ToHttpApiData a, Data.Singletons.Bool.SBoolI (Servant.API.Modifiers.FoldRequired' 'GHC.Types.False mods), Data.Typeable.Internal.Typeable a, Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryParam' mods sym a), Servant.CLI.Internal.HasCLI m api) => Servant.CLI.Internal.HasCLI m (Servant.API.QueryParam.QueryParam' mods sym a Servant.API.Sub.:> api)
instance (GHC.TypeLits.KnownSymbol sym, Servant.Docs.Internal.ToParam (Servant.API.QueryParam.QueryFlag sym), Servant.CLI.Internal.HasCLI m api) => Servant.CLI.Internal.HasCLI m (Servant.API.QueryParam.QueryFlag sym Servant.API.Sub.:> api)
instance forall k1 (m :: * -> *) (method :: k1) (status :: GHC.Types.Nat) (cts' :: [*]) a. (Servant.Client.Core.HasClient.HasClient m (Servant.API.Verbs.Verb method status cts' a), Servant.API.Verbs.ReflectMethod method) => Servant.CLI.Internal.HasCLI m (Servant.API.Verbs.Verb method status cts' a)
instance (GHC.TypeLits.KnownSymbol sym, Web.Internal.HttpApiData.FromHttpApiData a, Web.Internal.HttpApiData.ToHttpApiData a, Data.Singletons.Bool.SBoolI (Servant.API.Modifiers.FoldRequired' 'GHC.Types.False mods), Data.Typeable.Internal.Typeable a, Servant.CLI.Internal.HasCLI m api) => Servant.CLI.Internal.HasCLI m (Servant.API.Header.Header' mods sym a Servant.API.Sub.:> api)
instance Servant.CLI.Internal.HasCLI m api => Servant.CLI.Internal.HasCLI m (Network.HTTP.Types.Version.HttpVersion Servant.API.Sub.:> api)
instance (GHC.TypeLits.KnownSymbol desc, Servant.CLI.Internal.HasCLI m api) => Servant.CLI.Internal.HasCLI m (Servant.API.Description.Summary desc Servant.API.Sub.:> api)
instance (GHC.TypeLits.KnownSymbol desc, Servant.CLI.Internal.HasCLI m api) => Servant.CLI.Internal.HasCLI m (Servant.API.Description.Description desc Servant.API.Sub.:> api)
instance Servant.Client.Core.RunClient.RunClient m => Servant.CLI.Internal.HasCLI m Servant.API.Raw.Raw
instance Servant.CLI.Internal.HasCLI m api => Servant.CLI.Internal.HasCLI m (Data.Vault.Lazy.Vault Servant.API.Sub.:> api)
instance Servant.CLI.Internal.HasCLI m api => Servant.CLI.Internal.HasCLI m (Servant.API.RemoteHost.RemoteHost Servant.API.Sub.:> api)
instance Servant.CLI.Internal.HasCLI m api => Servant.CLI.Internal.HasCLI m (Servant.API.IsSecure.IsSecure Servant.API.Sub.:> api)
instance Servant.CLI.Internal.HasCLI m subapi => Servant.CLI.Internal.HasCLI m (Servant.API.WithNamedContext.WithNamedContext name context subapi)
instance forall k (m :: * -> *) api (tag :: k). Servant.CLI.Internal.HasCLI m api => Servant.CLI.Internal.HasCLI m (Servant.API.Experimental.Auth.AuthProtect tag Servant.API.Sub.:> api)
instance Servant.CLI.Internal.HasCLI m api => Servant.CLI.Internal.HasCLI m (Servant.API.BasicAuth.BasicAuth realm usr Servant.API.Sub.:> api)

module Servant.CLI

-- | Typeclass defining how each API combinator influences how a server can
--   be interacted with using command line options.
--   
--   Unless you are adding new combinators to be used with APIs, you can
--   ignore this class.
class HasCLI m api
type family CLI (m :: Type -> Type) (api :: Type) :: Type

-- | Create a structure for a command line parser.
clientPStruct :: HasCLI m api => Proxy api -> Proxy m -> PStruct (CLI m api)

-- | Parse a servant client; the result can be run. A good choice of
--   <tt>m</tt> is <tt>ClientM</tt>.
--   
--   It takes options on how the top-level prompt is displayed when given
--   <tt>"--help"</tt>; it can be useful for adding a header or program
--   description. Otherwise, just use <a>mempty</a>.
parseClient :: HasCLI m api => Proxy api -> Proxy m -> InfoMod (CLI m api) -> IO (CLI m api)

-- | A helper class for defining directly how to parse request bodies. This
--   allows more complex parsing of bodies.
class ParseBody a
parseBody :: ParseBody a => Parser a
parseBody :: (ParseBody a, Typeable a, Read a) => Parser a
defaultParseBody :: String -> ReadM a -> Parser a

-- | Convert a <a>PStruct</a> into a command line argument parser, from the
--   <i>optparse-applicative</i> library. It can be run with
--   <a>execParser</a>.
--   
--   It takes options on how the top-level prompt is displayed when given
--   <tt>"--help"</tt>; it can be useful for adding a header or program
--   description. Otherwise, just use <a>mempty</a>.
structParser :: PStruct a -> InfoMod a -> ParserInfo a

-- | The class that lets us display a sample input or output in the
--   supported content-types when generating documentation for endpoints
--   that either:
--   
--   <ul>
--   <li>expect a request body, or</li>
--   <li>return a non empty response body</li>
--   </ul>
--   
--   Example of an instance:
--   
--   <pre>
--   {-# LANGUAGE DeriveGeneric #-}
--   {-# LANGUAGE OverloadedStrings #-}
--   
--   import Data.Aeson
--   import Data.Text
--   import GHC.Generics
--   
--   data Greet = Greet { _msg :: Text }
--     deriving (Generic, Show)
--   
--   instance FromJSON Greet
--   instance ToJSON Greet
--   
--   instance ToSample Greet where
--     toSamples _ = singleSample g
--   
--       where g = Greet "Hello, haskeller!"
--   </pre>
--   
--   You can also instantiate this class using <a>toSamples</a> instead of
--   <a>toSample</a>: it lets you specify different responses along with
--   some context (as <a>ErrorMessage</a>) that explains when you're
--   supposed to get the corresponding response.
class ToSample a
toSamples :: ToSample a => Proxy a -> [(Text, a)]

-- | The class that helps us automatically get documentation for URL
--   captures.
--   
--   Example of an instance:
--   
--   <pre>
--   instance ToCapture (Capture "name" Text) where
--     toCapture _ = DocCapture "name" "name of the person to greet"
--   </pre>
class ToCapture (c :: k)
toCapture :: ToCapture c => Proxy c -> DocCapture

-- | A type to represent captures. Holds the name of the capture and a
--   description.
--   
--   Write a <a>ToCapture</a> instance for your captured types.
data DocCapture
DocCapture :: String -> String -> DocCapture
[_capSymbol] :: DocCapture -> String
[_capDesc] :: DocCapture -> String

-- | The class that helps us automatically get documentation for GET (or
--   other <a>Method</a>) parameters.
--   
--   Example of an instance:
--   
--   <pre>
--   instance ToParam (QueryParam' mods "capital" Bool) where
--     toParam _ =
--       DocQueryParam "capital"
--                     ["true", "false"]
--                     "Get the greeting message in uppercase (true) or not (false). Default is false."
--   </pre>
class ToParam (t :: k)
toParam :: ToParam t => Proxy t -> DocQueryParam

-- | A type to represent a <i>GET</i> (or other possible <a>Method</a>)
--   parameter from the Query String. Holds its name, the possible values
--   (leave empty if there isn't a finite number of them), and a
--   description of how it influences the output or behavior.
--   
--   Write a <a>ToParam</a> instance for your GET parameter types
data DocQueryParam
DocQueryParam :: String -> [String] -> String -> ParamKind -> DocQueryParam
[_paramName] :: DocQueryParam -> String
[_paramValues] :: DocQueryParam -> [String]
[_paramDesc] :: DocQueryParam -> String
[_paramKind] :: DocQueryParam -> ParamKind
